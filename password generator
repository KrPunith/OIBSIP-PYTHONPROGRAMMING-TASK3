#!/usr/bin/env python3
"""
Advanced Password Generator with Tkinter GUI
Compatible with Python 3.10

Features:
 - Length slider (8-128)
 - Toggle include lowercase, uppercase, digits, symbols
 - Option to exclude ambiguous characters (O0Il1 etc.)
 - Enforcement: require at least one of each chosen class
 - Advanced rules: forbid repeated chars, minimum unique chars, forbid sequences
 - Generate multiple passwords at once
 - Entropy calculation and strength meter
 - Copy to clipboard with auto-clear after timeout
 - Save to file
 - Password history and reveal/hide toggle
"""

import secrets
import string
import math
import time
import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# ---------- Configuration and small static lists ----------
AMBIGUOUS = "Il1Lo0O"
COMMON_PASSWORDS = {
    "123456", "password", "123456789", "12345678", "12345",
    "111111", "1234567", "sunshine", "qwerty", "iloveyou"
}

SYMBOLS_DEFAULT = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"

# ---------- Password generation utilities ----------

def build_charset(include_lower: bool, include_upper: bool, include_digits: bool,
                  include_symbols: bool, exclude_ambiguous: bool, extra_symbols: str = "") -> str:
    """Build the character set used for generation."""
    cs = ""
    if include_lower:
        cs += string.ascii_lowercase
    if include_upper:
        cs += string.ascii_uppercase
    if include_digits:
        cs += string.digits
    if include_symbols:
        cs += SYMBOLS_DEFAULT + extra_symbols
    if exclude_ambiguous:
        cs = "".join(ch for ch in cs if ch not in AMBIGUOUS)
    # remove duplicates while preserving order
    seen = set()
    final_cs = []
    for ch in cs:
        if ch not in seen:
            final_cs.append(ch)
            seen.add(ch)
    return "".join(final_cs)

def is_sequential(s: str, seq_min_len: int) -> bool:
    """Detect ascending or descending sequential substrings of length >= seq_min_len.
       Works for digits and letters."""
    if seq_min_len <= 1:
        return False
    n = len(s)
    for L in range(seq_min_len, n+1):
        for i in range(0, n - L + 1):
            sub = s[i:i+L]
            # Check alpha seq
            diffs = [ord(sub[j+1]) - ord(sub[j]) for j in range(len(sub)-1)]
            if all(d == 1 for d in diffs) or all(d == -1 for d in diffs):
                # Only consider if all are letters or all are digits or mix but sequential
                return True
    return False

def has_repeated_chars(s: str, max_repeat: int) -> bool:
    """Return True if any character repeats more than max_repeat consecutively."""
    if max_repeat < 1:
        return False
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
            if count > max_repeat:
                return True
        else:
            count = 1
    return False

def estimate_entropy(length: int, charset_size: int) -> float:
    """Estimate entropy in bits: length * log2(charset_size)"""
    if charset_size <= 1 or length <= 0:
        return 0.0
    return length * math.log2(charset_size)

def strength_label(entropy_bits: float) -> str:
    """Return textual rating based on entropy"""
    if entropy_bits < 28:
        return "Very Weak"
    if entropy_bits < 36:
        return "Weak"
    if entropy_bits < 60:
        return "Reasonable"
    if entropy_bits < 90:
        return "Strong"
    return "Very Strong"

def secure_shuffle_list(lst: list):
    """In-place secure shuffle."""
    for i in range(len(lst)-1, 0, -1):
        j = secrets.randbelow(i+1)
        lst[i], lst[j] = lst[j], lst[i]

def generate_password_once(length: int, charset: str,
                           require_each_class: dict,
                           forbid_sequences_len: int,
                           max_consecutive_repeat: int,
                           min_unique_chars: int,
                           forbid_common: bool,
                           max_attempts: int = 2000) -> str:
    """
    Generate a single password that attempts to satisfy the rules.
    Returns password string or raises ValueError if can't satisfy rules.
    """
    if not charset:
        raise ValueError("Character set is empty; cannot generate password.")
    # Build pools for each required class to ensure at least one present
    pools = {}
    if require_each_class.get("lower"):
        pools["lower"] = "".join(ch for ch in charset if ch.islower())
    if require_each_class.get("upper"):
        pools["upper"] = "".join(ch for ch in charset if ch.isupper())
    if require_each_class.get("digits"):
        pools["digits"] = "".join(ch for ch in charset if ch.isdigit())
    if require_each_class.get("symbols"):
        pools["symbols"] = "".join(ch for ch in charset if not ch.isalnum())

    attempts = 0
    while attempts < max_attempts:
        attempts += 1
        # Start with required characters
        pw_chars = []
        for k, pool in pools.items():
            if pool:
                pw_chars.append(secrets.choice(pool))
        # Fill the rest
        while len(pw_chars) < length:
            pw_chars.append(secrets.choice(charset))
        # Shuffle securely
        secure_shuffle_list(pw_chars)
        candidate = "".join(pw_chars)

        # Rule checks
        if forbid_sequences_len and is_sequential(candidate, forbid_sequences_len):
            continue
        if max_consecutive_repeat is not None and has_repeated_chars(candidate, max_consecutive_repeat):
            continue
        if min_unique_chars and len(set(candidate)) < min_unique_chars:
            continue
        if forbid_common and candidate.lower() in COMMON_PASSWORDS:
            continue
        # all good
        return candidate

    raise ValueError("Unable to generate a password satisfying constraints after many attempts.")


# ---------- Tkinter UI ----------

class PasswordGeneratorApp:
    def __init__(self, root: tk.Tk):
        self.root = root
        root.title("Advanced Password Generator")
        root.geometry("980x640")
        root.minsize(880, 560)
        self.clipboard_clear_after_ms = 30_000  # 30 seconds default

        # Styles
        style = ttk.Style()
        style.theme_use("clam")

        # Main frame
        main = ttk.Frame(root, padding=(10,10))
        main.pack(fill=tk.BOTH, expand=True)

        # Left: controls
        ctrl_frame = ttk.LabelFrame(main, text="Options", padding=(10,10))
        ctrl_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0,8), pady=4)

        # Complexity options
        complexity_frame = ttk.LabelFrame(ctrl_frame, text="Complexity", padding=(8,8))
        complexity_frame.pack(fill=tk.X, pady=(0,8))

        self.var_lower = tk.BooleanVar(value=True)
        self.var_upper = tk.BooleanVar(value=True)
        self.var_digits = tk.BooleanVar(value=True)
        self.var_symbols = tk.BooleanVar(value=True)
        self.var_exclude_ambig = tk.BooleanVar(value=True)

        ttk.Checkbutton(complexity_frame, text="Lowercase (a-z)", variable=self.var_lower).pack(anchor=tk.W)
        ttk.Checkbutton(complexity_frame, text="Uppercase (A-Z)", variable=self.var_upper).pack(anchor=tk.W)
        ttk.Checkbutton(complexity_frame, text="Digits (0-9)", variable=self.var_digits).pack(anchor=tk.W)
        ttk.Checkbutton(complexity_frame, text="Symbols (e.g. !@#)", variable=self.var_symbols).pack(anchor=tk.W)
        ttk.Checkbutton(complexity_frame, text="Exclude ambiguous (O0Il1)", variable=self.var_exclude_ambig).pack(anchor=tk.W)

        # Length and generation count
        length_frame = ttk.LabelFrame(ctrl_frame, text="Length & Count", padding=(8,8))
        length_frame.pack(fill=tk.X, pady=(0,8))
        self.length_var = tk.IntVar(value=16)
        ttk.Label(length_frame, text="Length:").pack(anchor=tk.W)
        length_scale = ttk.Scale(length_frame, from_=6, to=128, orient=tk.HORIZONTAL, command=self.on_length_scale)
        length_scale.set(self.length_var.get())
        length_scale.pack(fill=tk.X)
        self.length_spin = ttk.Spinbox(length_frame, from_=6, to=128, textvariable=self.length_var, width=6)
        self.length_spin.pack(anchor=tk.E, pady=(4,0))

        ttk.Label(length_frame, text="Generate count:").pack(anchor=tk.W, pady=(8,0))
        self.count_var = tk.IntVar(value=4)
        self.count_spin = ttk.Spinbox(length_frame, from_=1, to=50, textvariable=self.count_var, width=6)
        self.count_spin.pack(anchor=tk.E)

        # Advanced rules
        adv_frame = ttk.LabelFrame(ctrl_frame, text="Advanced Rules", padding=(8,8))
        adv_frame.pack(fill=tk.X, pady=(0,8))

        ttk.Label(adv_frame, text="Forbid sequential runs length â‰¥").pack(anchor=tk.W)
        self.seq_len_var = tk.IntVar(value=4)
        ttk.Spinbox(adv_frame, from_=2, to=10, textvariable=self.seq_len_var, width=6).pack(anchor=tk.E)

        ttk.Label(adv_frame, text="Max consecutive repeated chars (0 = no limit)").pack(anchor=tk.W, pady=(6,0))
        self.max_repeat_var = tk.IntVar(value=2)
        ttk.Spinbox(adv_frame, from_=0, to=10, textvariable=self.max_repeat_var, width=6).pack(anchor=tk.E)

        ttk.Label(adv_frame, text="Minimum unique characters").pack(anchor=tk.W, pady=(6,0))
        self.min_unique_var = tk.IntVar(value=4)
        ttk.Spinbox(adv_frame, from_=1, to=128, textvariable=self.min_unique_var, width=6).pack(anchor=tk.E)

        self.var_forbid_common = tk.BooleanVar(value=True)
        ttk.Checkbutton(adv_frame, text="Forbid a few common weak passwords", variable=self.var_forbid_common).pack(anchor=tk.W, pady=(6,0))

        # Clipboard settings and actions
        cb_frame = ttk.LabelFrame(ctrl_frame, text="Clipboard & Actions", padding=(8,8))
        cb_frame.pack(fill=tk.X, pady=(0,8))
        ttk.Label(cb_frame, text="Auto-clear clipboard after (sec):").pack(anchor=tk.W)
        self.clip_clear_var = tk.IntVar(value=30)
        ttk.Spinbox(cb_frame, from_=5, to=300, textvariable=self.clip_clear_var, width=6).pack(anchor=tk.E)

        # Extra symbols input
        ttk.Label(ctrl_frame, text="Extra symbols to include (optional):").pack(anchor=tk.W)
        self.extra_symbols_var = tk.StringVar(value="")
        ttk.Entry(ctrl_frame, textvariable=self.extra_symbols_var).pack(fill=tk.X, pady=(0,8))

        # Generate button
        btn_frame = ttk.Frame(ctrl_frame)
        btn_frame.pack(fill=tk.X, pady=(6,0))
        ttk.Button(btn_frame, text="Generate Passwords", command=self.generate_passwords).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(0,4))
        ttk.Button(btn_frame, text="Save List...", command=self.save_list).pack(side=tk.LEFT, fill=tk.X, padx=(4,0))

        # Right: results & metrics
        right_frame = ttk.Frame(main)
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Top result area
        result_frame = ttk.LabelFrame(right_frame, text="Passwords", padding=(8,8))
        result_frame.pack(fill=tk.BOTH, expand=True, padx=(0,4), pady=(0,6))

        # Controls above list
        top_controls = ttk.Frame(result_frame)
        top_controls.pack(fill=tk.X, pady=(0,8))
        ttk.Button(top_controls, text="Copy Selected", command=self.copy_selected).pack(side=tk.RIGHT)
        ttk.Button(top_controls, text="Copy All", command=self.copy_all).pack(side=tk.RIGHT, padx=(6,0))
        self.show_passwords_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(top_controls, text="Reveal passwords", variable=self.show_passwords_var, command=self.toggle_reveal).pack(side=tk.LEFT)

        # Password listbox with scrollbar
        list_frame = ttk.Frame(result_frame)
        list_frame.pack(fill=tk.BOTH, expand=True)
        self.passwords_var = tk.Variable(value=[])
        self.listbox = tk.Listbox(list_frame, listvariable=self.passwords_var, height=12, selectmode=tk.EXTENDED, font=("Consolas", 11))
        self.listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.listbox.config(yscrollcommand=scrollbar.set)

        # Details panel
        detail_frame = ttk.LabelFrame(right_frame, text="Details & Strength", padding=(8,8))
        detail_frame.pack(fill=tk.X)

        stats_row = ttk.Frame(detail_frame)
        stats_row.pack(fill=tk.X)
        ttk.Label(stats_row, text="Entropy (bits):").grid(row=0, column=0, sticky=tk.W, padx=(0,6))
        self.entropy_var = tk.StringVar(value="0")
        ttk.Label(stats_row, textvariable=self.entropy_var).grid(row=0, column=1, sticky=tk.W)

        ttk.Label(stats_row, text="Strength:").grid(row=0, column=2, sticky=tk.W, padx=(10,6))
        self.strength_var = tk.StringVar(value="N/A")
        ttk.Label(stats_row, textvariable=self.strength_var).grid(row=0, column=3, sticky=tk.W)

        ttk.Label(stats_row, text="Charset size:").grid(row=1, column=0, sticky=tk.W, padx=(0,6), pady=(6,0))
        self.charset_var = tk.StringVar(value="0")
        ttk.Label(stats_row, textvariable=self.charset_var).grid(row=1, column=1, sticky=tk.W, pady=(6,0))

        # Strength progress bar
        self.strength_bar = ttk.Progressbar(detail_frame, length=360, mode="determinate", maximum=120)
        self.strength_bar.pack(fill=tk.X, pady=(8,4))

        # Status bar
        self.status_var = tk.StringVar(value="Ready.")
        status = ttk.Label(root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        status.pack(fill=tk.X, side=tk.BOTTOM)

        # Initialize default passwords
        self.generated_passwords = []

    # ---------- UI callbacks ----------
    def on_length_scale(self, val):
        try:
            v = int(float(val))
        except Exception:
            v = 16
        self.length_var.set(v)

    def toggle_reveal(self):
        # If revealing, show actual passwords; else mask them (e.g., with â€¢)
        if self.show_passwords_var.get():
            self.listbox.config(font=("Consolas", 11))
            self.update_listbox_display()
        else:
            # masked
            self.listbox.config(font=("Consolas", 11))
            self.update_listbox_display()

    def update_listbox_display(self):
        display = []
        reveal = self.show_passwords_var.get()
        for p in self.generated_passwords:
            display.append(p if reveal else "â€¢" * len(p))
        self.passwords_var.set(display)

    def generate_passwords(self):
        # Read options
        length = int(self.length_var.get())
        count = int(self.count_var.get())
        include_lower = self.var_lower.get()
        include_upper = self.var_upper.get()
        include_digits = self.var_digits.get()
        include_symbols = self.var_symbols.get()
        exclude_ambig = self.var_exclude_ambig.get()
        extra_symbols = self.extra_symbols_var.get() or ""
        seq_len = int(self.seq_len_var.get())
        max_repeat = int(self.max_repeat_var.get())
        if max_repeat == 0:
            max_repeat = None
        min_unique = int(self.min_unique_var.get())
        forbid_common = self.var_forbid_common.get()

        charset = build_charset(include_lower, include_upper, include_digits, include_symbols, exclude_ambig, extra_symbols)
        if not charset:
            messagebox.showwarning("Empty character set", "No characters selected for generation. Choose at least one character type.")
            return

        require_each = {
            "lower": include_lower,
            "upper": include_upper,
            "digits": include_digits,
            "symbols": include_symbols
        }

        # generate
        self.generated_passwords = []
        failed = 0
        last_exception = None
        for i in range(count):
            try:
                pw = generate_password_once(
                    length=length,
                    charset=charset,
                    require_each_class=require_each,
                    forbid_sequences_len=seq_len,
                    max_consecutive_repeat=max_repeat,
                    min_unique_chars=min_unique,
                    forbid_common=forbid_common,
                )
                self.generated_passwords.append(pw)
            except ValueError as e:
                failed += 1
                last_exception = e
                break

        if failed:
            messagebox.showerror("Generation error", f"Could not generate requested passwords:\n{last_exception}")
            self.status_var.set("Generation failed.")
            return

        # Update UI and stats (use first generated for stats)
        self.update_listbox_display()
        cs_size = len(set(charset))
        self.charset_var.set(str(cs_size))
        ent = estimate_entropy(length, cs_size)
        self.entropy_var.set(f"{ent:.1f}")
        strength = strength_label(ent)
        self.strength_var.set(strength)
        # map entropy to progress bar (0..120)
        val = min(max(ent, 0), 120)
        self.strength_bar['value'] = val
        self.status_var.set(f"Generated {len(self.generated_passwords)} password(s).")
        # auto-select top entry
        if self.generated_passwords:
            self.listbox.selection_clear(0, tk.END)
            self.listbox.selection_set(0)

    def copy_selected(self):
        sel = list(self.listbox.curselection())
        if not sel:
            messagebox.showinfo("No selection", "Select one or more passwords to copy.")
            return
        # copy selected actual passwords joined by newline
        passwords = [self.generated_passwords[i] for i in sel]
        self._copy_to_clipboard("\n".join(passwords))
        self.status_var.set(f"Copied {len(passwords)} password(s) to clipboard.")

    def copy_all(self):
        if not self.generated_passwords:
            messagebox.showinfo("No passwords", "No passwords to copy. Generate some first.")
            return
        self._copy_to_clipboard("\n".join(self.generated_passwords))
        self.status_var.set(f"Copied all {len(self.generated_passwords)} password(s) to clipboard.")

    def save_list(self):
        if not self.generated_passwords:
            messagebox.showinfo("No passwords", "No passwords to save. Generate some first.")
            return
        fpath = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files","*.txt"),("All files","*.*")])
        if not fpath:
            return
        try:
            with open(fpath, "w", encoding="utf-8") as f:
                for p in self.generated_passwords:
                    f.write(p + "\n")
            self.status_var.set(f"Saved {len(self.generated_passwords)} password(s) to {fpath}")
        except Exception as e:
            messagebox.showerror("Save error", f"Unable to save file: {e}")

    def _copy_to_clipboard(self, text: str):
        # Put on clip and schedule clearing after configured seconds
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(text)
            self.root.update()  # now it stays on clipboard
            sec = int(self.clip_clear_var.get())
            ms = max(1000, sec * 1000)
            # schedule clearing
            self.root.after_cancel(getattr(self, "_clip_clear_after_id", ""))
            self._clip_clear_after_id = self.root.after(ms, self._clear_clipboard)
            # Note: we don't persist the id separately if app closes
            # But keep a variable with id in self
        except Exception as e:
            messagebox.showerror("Clipboard error", f"Could not copy to clipboard: {e}")

    def _clear_clipboard(self):
        try:
            # Clear only if it matches one of our generated passwords to avoid wiping unrelated clipboard
            try:
                current = self.root.clipboard_get()
            except tk.TclError:
                current = None
            if current and current in ("\n".join(self.generated_passwords),) or current in self.generated_passwords or any(current == p for p in self.generated_passwords):
                self.root.clipboard_clear()
                self.status_var.set("Clipboard cleared for security.")
            else:
                self.status_var.set("Clipboard left untouched (different content).")
        except Exception:
            pass

# ---------- Run the app ----------

def main():
    root = tk.Tk()
    app = PasswordGeneratorApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()
